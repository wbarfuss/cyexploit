import numpy as np
import networkx as nx
from pstats import Stats
import cProfile
from os import system  # path, makedirs
from time import time


def create_list_of_adj_mats(n_runs):
    adj_mats = []
    np.random.seed(42)
    for i in xrange(n_runs):
        # Creating connected adj matrix
        net = nx.erdos_renyi_graph(N, link_density)
        while len(list(nx.connected_components(net))) > 1:
            print "Network has isolated components. Try again!"
            net = nx.erdos_renyi_graph(N, link_density)
        adj_mats.append(nx.adj_matrix(net).toarray())

    return adj_mats


def profiling(print_stats):
    """
    Run the model for the given set of parameters and additionally perform
    some profiling.
    """
    cProfile.runctx("sample_runs(n_runs, single_steps, N, link_density," +
                    "rewiring_prob, update_timescale, adj_mats)",
                    globals(), locals(), "profile.prof")
    s = Stats("profile.prof")
    if print_stats:
        s.strip_dirs().sort_stats("time").print_stats()
    system("rm profile.prof")


def sample_runs(n_runs, single_steps, N, link_density, rewiring_prob,
                update_timescale,
                adj_mats):
    n = 0
    n_fails = 0

    while n < n_runs:
        print "Run:", n+1

        # Agent's parameters
        Stocks = np.ones(N)
        MaxStocks = np.ones(N)
        GrowthRates = np.ones(N)
        Rationalities = np.ones(N)
        Strategies = np.random.randint(2, size=N)

        # Running the model
        t0 = time()
        m = Exploit(adj_mats[n], Strategies, Stocks, MaxStocks, GrowthRates,
                    Rationalities, rewiring_prob, update_timescale)

        if single_steps == -1:
            fail = (m.run() == 0)
            print "Runtime: {0} min".format((time()-t0)/60.)

            if fail:
                print "No conv., in run", n+1
                n_fails += 1
            elif not fail:
                print "<sus>: {}".format(m.get_strategies().mean())
                n += 1
        else:
            m.run(steps=single_steps)
            n += 1

            print "Runtime: {0} min".format((time()-t0)/60.)

    print "Done!"


if __name__ == "__main__":

    use_cy = True

    do_profiling = True     # print statistics on performace of the script
    print_stats = True
    single_steps = -1       # if -1 run into consensus
    n_runs = 10             # Number of sample_runs
    N = 500                 # The number of nodes in the network
    rewiring_prob = 1.0     # The adaptive rewiring probability
    update_timescale = 1.0  # The social update time
    link_density = 0.35     # The link density of the social network

    # For optimizing core
    # (n_runs, single_steps, N) = (10, 600, 500)
    # For final runs
    (n_runs, single_steps, N) = (5, -1, 300)
    # Paramteters
    (update_timescale, rewiring_prob) = (1.0, 0.0)

    adj_mats = create_list_of_adj_mats(n_runs)

    if use_cy:
        from cyexploit import ExploitCore as Exploit
    else:
        from exploit_model import ExploitModel as Exploit

    if do_profiling:
        profiling(print_stats)

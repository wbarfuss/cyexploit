"""
This "experiment_handling" module provides functionality to run a computer
model for various parameter combinations and sample sizes.
@author: wbarfuss
"""
import os
import sys
import numpy as np
import glob


def compute(run_func, parameter_combinations, sample_size, save_path):
    """
    Calls the ´run_func´ for several ´parameter_combiantions´ and
    ´sample_size´s and provides a unique ID for each run to store the data at
    the ´save_path´ + ID

    Parameters
    ----------
    run_func : function
        The function the executes the model for a given set of parameters.
        The first P paramters need to fit to the parameter_combinations.
        The last parameter of run_func has to be named filename
        If all went well run_func needs to return ´1´, otherwise another number
    parameter_combinations : list
        A list of tuples of each parameter combination to compute
    sample_size : int
        The size of samples of each parameter combiantion
    save_path : string
        The path to the folder where to store the computed results
    """
    # add "/" to save_path if it does not end already with a "/"
    save_path += "/" if not save_path.endswith("/") else ""
    if not os.path.exists(save_path):
        os.makedirs(save_path)

    # Obtaining the data
    tocalc = []
    for s in range(sample_size):
        for p in parameter_combinations:
            if not os.path.exists(save_path + _get_ID(p, s)):
                tocalc.append((p, s))

    lentocalc = len(tocalc)
    print ("%i%% already computed" % (100 - (float(lentocalc) * 100 /
           len(parameter_combinations) / sample_size)))

    for i, (p, s) in enumerate(tocalc):
        _progress_report(i, lentocalc, "Computation... ")
        exit_status = run_func(*p, filename=save_path + _get_ID(p, s))
        if exit_status != 1:  # Checking for expected execution
            # TODO: proper logging
            print "!!! " + _get_ID(p, s) + " returned with: " \
                + str(exit_status)


def find_bad_ones(missing_key, save_path):
    """
    Find model runs that did not properly.

    Parameters
    ----------
    missing_key : string
        The key of the saved result dictionary that misses in not properly
        computed model runs
    save_path : string
        The path to the folder where to store the computed results

    Returns
    -------
    bad_ones : list
        List of filenames that where did not properly run
    """
    # add "/" to save_path if it does not end already with a "/"
    save_path += "/" if not save_path.endswith("/") else ""
    d = glob.glob("{}*".format(save_path))

    bad_ones = []
    for f in d:
        resdic = np.load(f)
        if missing_key not in resdic:
            bad_ones.append(f[f.rfind("/")+1:-4])
    return bad_ones


def _get_ID(parameter_combination, i):
    """
    Get a unique ID for a ´parameter_combination´ and a sample ´i´.

    Parameters
    ----------
    parameter_combination : tuple
        The combination of parameters
    i : int
        The sample

    Returns
    -------
    ID : string
        unique ID plus the ".pkl" ending
    """

    res = str(parameter_combination)  # convert to sting
    res = res[1:-1]  # delete brackets
    res = res.replace(", ", "_")  # replace ", " with "_"
    res = res.replace(".", "o")  # replace dots with an "o"
    res += "_s" + str(i)  # add sample size
    res += ".pkl"  # add file type
    return res


def _progress_report(i, loop_length, msg=""):
    """
    A small progress report for a loop of defined length.

    Parameters
    ----------
    i : int
        the current position in the loop
    loop_length : int
        the length of the loop
    msg : string
        (optional) a preceding string
    """
    percent = str(int(np.around(float(i)/loop_length, 2) * 100))
    sys.stdout.write("\r")
    sys.stdout.flush()
    sys.stdout.write(msg + " [" + percent + "%] ")
    sys.stdout.flush()

    if i == loop_length-1:
        sys.stdout.write("\n")
        sys.stdout.flush()
